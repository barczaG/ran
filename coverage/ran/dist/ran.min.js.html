<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for ran/dist/ran.min.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../prettify.css" />
    <link rel="stylesheet" href="../../base.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../sort-arrow-sprite.png);
        }
    </style>
</head>
<body>
<div class='wrapper'>
  <div class='pad1'>
    <h1>
      <a href="../../index.html">All files</a> / <a href="index.html">ran/dist</a> ran.min.js
    </h1>
    <div class='clearfix'>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Statements</span>
        <span class='fraction'>0/597</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Branches</span>
        <span class='fraction'>0/439</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Functions</span>
        <span class='fraction'>0/306</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Lines</span>
        <span class='fraction'>0/1</span>
      </div>
    </div>
    <p class="quiet">
      Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
    </p>
  </div>
  <div class='status-line low'></div>
<pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">var ran=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){var s=<span class="cstat-no" title="statement not covered" >{};</span>function <span class="fstat-no" title="function not covered" >e(</span>h){<span class="cstat-no" title="statement not covered" >if(s[h])<span class="cstat-no" title="statement not covered" >return s[h].exports;v</span></span>ar r=<span class="cstat-no" title="statement not covered" >s[h]={i:h,l:!1,exports:{}};<span class="cstat-no" title="statement not covered" ></span>return t[h].call(r.exports,r,r.exports,e),r.l=!0,r.exports}<span class="cstat-no" title="statement not covered" ></span>return e.m=t,e.c=s,e.d=<span class="fstat-no" title="function not covered" >fu</span>nction(t,s,h){<span class="cstat-no" title="statement not covered" >e.o(t,s)||Object.defineProperty(t,s,{enumerable:!0,get:h})}</span>,e.r=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >"undefined"!=typeof Symbol&amp;&amp;Symbol.toStringTag&amp;&amp;Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}</span>,e.t=<span class="fstat-no" title="function not covered" >fu</span>nction(t,s){<span class="cstat-no" title="statement not covered" >if(1&amp;s&amp;&amp;(t=e(t)),8&amp;s)<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >i</span></span>f(4&amp;s&amp;&amp;"object"==typeof t&amp;&amp;t&amp;&amp;t.__esModule)<span class="cstat-no" title="statement not covered" >return t;v</span></span>ar h=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>if(e.r(h),Object.defineProperty(h,"default",{enumerable:!0,value:t}),2&amp;s&amp;&amp;"string"!=typeof t)<span class="cstat-no" title="statement not covered" >for(var r in t)<span class="cstat-no" title="statement not covered" >e.d(h,r,<span class="fstat-no" title="function not covered" >fu</span>nction(s){<span class="cstat-no" title="statement not covered" >return t[s]}</span>.bind(null,r));<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn h}</span>,e.n=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var s=<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.__esModule?<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return t.default}</span>:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return t}</span>;<span class="cstat-no" title="statement not covered" ></span>return e.d(s,"a",s),s}</span>,e.o=<span class="fstat-no" title="function not covered" >fu</span>nction(t,s){<span class="cstat-no" title="statement not covered" >return Object.prototype.hasOwnProperty.call(t,s)}</span>,e.p="",e(e.s=0)}</span>([<span class="fstat-no" title="function not covered" >fu</span>nction(t,s,e){"use strict";function <span class="fstat-no" title="function not covered" >h(</span>t=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >return t&lt;s?Math.random()*(s-t)+t:Math.random()*(t-s)+s}</span>function <span class="fstat-no" title="function not covered" >r(</span>t,s=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >return s&lt;2?t():Array.from({length:s},<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t())</span>}<span class="cstat-no" title="statement not covered" ></span>e.r(s);v</span>ar a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{float:<span class="fstat-no" title="function not covered" >fu</span>nction(t,s,e){<span class="cstat-no" title="statement not covered" >return 0===arguments.length?Math.random():1===arguments.length?Math.random()*t:r(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >h(t,s),</span>e)}</span>,int:<span class="fstat-no" title="function not covered" >fu</span>nction(t,s,e){<span class="cstat-no" title="statement not covered" >return 1===arguments.length?Math.floor(Math.random()*(t+1)):r(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Math.floor(h(t,s+1)),</span>e)}</span>,choice:<span class="fstat-no" title="function not covered" >fu</span>nction(t,s){<span class="cstat-no" title="statement not covered" >return null==t||0===t.length?null:r(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t[Math.floor(Math.random()*t.length)],</span>s)}</span>,char:<span class="fstat-no" title="function not covered" >fu</span>nction(t,s){<span class="cstat-no" title="statement not covered" >return null==t||0===t.length?null:r(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.charAt(Math.floor(Math.random()*t.length)),</span>s)}</span>,shuffle:<span class="fstat-no" title="function not covered" >fu</span>nction(t){let s,e,h=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ></span>for(;h;)<span class="cstat-no" title="statement not covered" >s=Math.floor(Math.random()*h--),e=t[h],t[h]=t[s],t[s]=e;<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>,coin:<span class="fstat-no" title="function not covered" >fu</span>nction(t,s,e=<span class="branch-0 cbranch-no" title="branch not covered" >.5,</span>h=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >return r(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Math.random()&lt;e?t:s,</span>h)}</span>}}</span>(),</span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){class t{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >"number"==typeof t?(this._v=new Array(t).fill(0),this._v[0]=1):Array.isArray(t)?this._v=t:"object"==typeof t&amp;&amp;Array.isArray(t._v)?this._v=t._v:this._v=[1,0,0]}<span class="fstat-no" title="function not covered" ></span>v(</span>){<span class="cstat-no" title="statement not covered" >return this._v}<span class="fstat-no" title="function not covered" ></span>i(</span>t,s){<span class="cstat-no" title="statement not covered" >if(void 0===s)<span class="cstat-no" title="statement not covered" >return this._v[t];<span class="cstat-no" title="statement not covered" >t</span></span>his._v[t]=s}<span class="fstat-no" title="function not covered" ></span>f(</span>s){<span class="cstat-no" title="statement not covered" >return new t(this._v.map(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >s(t))</span>)}<span class="fstat-no" title="function not covered" ></span>sc</span>ale(s){<span class="cstat-no" title="statement not covered" >return new t(this._v.map(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t*s)</span>)}<span class="fstat-no" title="function not covered" ></span>ad</span>d(s){let e=<span class="cstat-no" title="statement not covered" >s.v();<span class="cstat-no" title="statement not covered" ></span>return new t(this._v.map(<span class="fstat-no" title="function not covered" >(t</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >t+e[s])</span>)}<span class="fstat-no" title="function not covered" ></span>do</span>t(t){let s=<span class="cstat-no" title="statement not covered" >t.v();<span class="cstat-no" title="statement not covered" ></span>return this._v.reduce(<span class="fstat-no" title="function not covered" >(t</span>,e,h)=&gt;<span class="cstat-no" title="statement not covered" >t+e*s[h],</span>0)}</span>}class s{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >if("number"==typeof t){<span class="cstat-no" title="statement not covered" >this._m=Array.from({length:t},<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >new Array(t).fill(0))</span>;<span class="cstat-no" title="statement not covered" >f</span>or(let s=0;s&lt;t;s++)<span class="cstat-no" title="statement not covered" >this._m[s][s]=1}</span></span>else <span class="cstat-no" title="statement not covered" >Array.isArray(t)?this._m=t:"object"==typeof t&amp;&amp;Array.isArray(t._m)?this._m=t._m:this._m=[[1,0,0],[0,1,0],[0,0,1]]}<span class="fstat-no" title="function not covered" ></span></span>m(</span>){<span class="cstat-no" title="statement not covered" >return this._m.map(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.slice())</span>}<span class="fstat-no" title="function not covered" ></span>ij</span>(t,s,e){<span class="cstat-no" title="statement not covered" >if(void 0===e)<span class="cstat-no" title="statement not covered" >return this._m[t][s];<span class="cstat-no" title="statement not covered" >t</span></span>his._m[t][s]=e}<span class="fstat-no" title="function not covered" ></span>f(</span>t){<span class="cstat-no" title="statement not covered" >return new s(this._m.map(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >s.map(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >t(s))</span>)</span>)}<span class="fstat-no" title="function not covered" ></span>sc</span>ale(t){<span class="cstat-no" title="statement not covered" >return this.f(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >s*t)</span>}<span class="fstat-no" title="function not covered" ></span>ad</span>d(t){let e=<span class="cstat-no" title="statement not covered" >t.m();<span class="cstat-no" title="statement not covered" ></span>return new s(this._m.map(<span class="fstat-no" title="function not covered" >(t</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >t.map(<span class="fstat-no" title="function not covered" >(t</span>,h)=&gt;<span class="cstat-no" title="statement not covered" >t+e[s][h])</span>)</span>)}<span class="fstat-no" title="function not covered" ></span>mu</span>lt(t){let e=<span class="cstat-no" title="statement not covered" >t.m(),</span>h=<span class="cstat-no" title="statement not covered" >this._m.length,</span>r=<span class="cstat-no" title="statement not covered" >new s(h);<span class="cstat-no" title="statement not covered" ></span>for(let t=0;t&lt;h;t++)<span class="cstat-no" title="statement not covered" >for(let s=0;s&lt;h;s++){let a=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let r=0;r&lt;h;r++)<span class="cstat-no" title="statement not covered" >a+=this._m[t][r]*e[r][s];<span class="cstat-no" title="statement not covered" >r</span></span>.ij(t,s,a)}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn r}<span class="fstat-no" title="function not covered" ></span>t(</span>){<span class="cstat-no" title="statement not covered" >return new s(this._m[0].map(<span class="fstat-no" title="function not covered" >(t</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >this._m.map(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t[s])</span>)</span>)}<span class="fstat-no" title="function not covered" ></span>ac</span>t(s){<span class="cstat-no" title="statement not covered" >return new t(this._m.map(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >s.dot(new t(e)))</span>)}<span class="fstat-no" title="function not covered" ></span>ld</span>l(){let t=<span class="cstat-no" title="statement not covered" >this._m.length,</span>e=<span class="cstat-no" title="statement not covered" >new s(t),</span>h=<span class="cstat-no" title="statement not covered" >new s(t);<span class="cstat-no" title="statement not covered" ></span>for(let s=0;s&lt;t;s++){let r=<span class="cstat-no" title="statement not covered" >this.ij(s,s);<span class="cstat-no" title="statement not covered" ></span>for(let t=0;t&lt;s;t++)<span class="cstat-no" title="statement not covered" >r-=e.ij(t,t)*h.ij(s,t)*h.ij(s,t);<span class="cstat-no" title="statement not covered" >e</span></span>.ij(s,s,r);<span class="cstat-no" title="statement not covered" >f</span>or(let a=t-1;a&gt;s;a--){let t=<span class="cstat-no" title="statement not covered" >this.ij(a,s);<span class="cstat-no" title="statement not covered" ></span>for(let r=0;r&lt;s;r++)<span class="cstat-no" title="statement not covered" >t-=e.ij(r,r)*h.ij(a,r)*h.ij(s,r);<span class="cstat-no" title="statement not covered" >h</span></span>.ij(a,s,t/r)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{D:e,L:h}}</span>}<span class="cstat-no" title="statement not covered" >return{Vector:t,Matrix:s}}</span>(),</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){const t=<span class="cstat-no" title="statement not covered" >100,</span>s=<span class="cstat-no" title="statement not covered" >1e-10;</span>let e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){const t=<span class="cstat-no" title="statement not covered" >[676.5203681218851,-1259.1392167224028,771.3234287776531,-176.6150291621406,12.507343278686905,-.13857109526572012,9984369578019572e-21,1.5056327351493116e-7];<span class="cstat-no" title="statement not covered" ></span>return function <span class="fstat-no" title="function not covered" >s(</span>e){let h=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(e&lt;.5)<span class="cstat-no" title="statement not covered" >h=Math.PI/(Math.sin(Math.PI*e)*s(1-e));e</span>lse{<span class="cstat-no" title="statement not covered" >e--;l</span>et s=<span class="cstat-no" title="statement not covered" >.9999999999998099,</span>r=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ></span>t.forEach(<span class="fstat-no" title="function not covered" >(t</span>,a)=&gt;{<span class="cstat-no" title="statement not covered" >s+=t/(e+a+1);l</span>et i=<span class="cstat-no" title="statement not covered" >e+r-.5;<span class="cstat-no" title="statement not covered" ></span>h=Math.sqrt(2*Math.PI)*Math.pow(i,e+.5)*Math.exp(-i)*s}</span>)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn h}</span>}</span>(),</span>h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){const t=<span class="cstat-no" title="statement not covered" >[76.18009172947146,-86.50532032941678,24.01409824083091,-1.231739572450155,.001208650973866179,-5395239384953e-18];<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(s){let e=<span class="cstat-no" title="statement not covered" >s,</span>h=<span class="cstat-no" title="statement not covered" >s,</span>r=<span class="cstat-no" title="statement not covered" >e+5.5;<span class="cstat-no" title="statement not covered" ></span>r=(e+.5)*Math.log(r)-r;l</span>et a=<span class="cstat-no" title="statement not covered" >1.000000000190015;<span class="cstat-no" title="statement not covered" ></span>for(let s=0;s&lt;6;s++)<span class="cstat-no" title="statement not covered" >a+=t[s]/++h;<span class="cstat-no" title="statement not covered" >r</span></span>eturn r+Math.log(2.5066282746310007*a/e)}</span>}</span>(),</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){const h=<span class="cstat-no" title="statement not covered" >1e-30;<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(r,a){<span class="cstat-no" title="statement not covered" >return a&lt;r+1?<span class="fstat-no" title="function not covered" >fu</span>nction(e,h){<span class="cstat-no" title="statement not covered" >if(h&lt;0)<span class="cstat-no" title="statement not covered" >return 0;{</span></span>let r=<span class="cstat-no" title="statement not covered" >e,</span>a=<span class="cstat-no" title="statement not covered" >1/e,</span>i=<span class="cstat-no" title="statement not covered" >1/e;<span class="cstat-no" title="statement not covered" ></span>for(let e=0;e&lt;t&amp;&amp;!((a*=h/++r)&lt;(i+=a)*s);e++);<span class="cstat-no" title="statement not covered" >r</span>eturn Math.exp(-h)*Math.pow(h,e)*i}</span>}(r,a):e(r)-<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){let a,i,n=<span class="cstat-no" title="statement not covered" >r+1-e,</span>p=<span class="cstat-no" title="statement not covered" >1/h,</span>o=<span class="cstat-no" title="statement not covered" >1/n,</span>u=<span class="cstat-no" title="statement not covered" >o;<span class="cstat-no" title="statement not covered" ></span>for(let r=1;r&lt;t&amp;&amp;(o=(a=r*(e-r))*o+(n+=2),Math.abs(o)&lt;h&amp;&amp;(o=h),o=1/o,p=n+a/p,Math.abs(p)&lt;h&amp;&amp;(p=h),u*=i=p*o,!(Math.abs(i-1)&lt;s));r++);<span class="cstat-no" title="statement not covered" >r</span>eturn Math.exp(-r)*Math.pow(r,e)*u}</span>(r,a)}</span>}</span>();<span class="cstat-no" title="statement not covered" ></span>return{beta:<span class="fstat-no" title="function not covered" >fu</span>nction(t,s){<span class="cstat-no" title="statement not covered" >return Math.exp(h(t)+h(s)-h(t+s))}</span>,betaIncomplete:<span class="fstat-no" title="function not covered" >fu</span>nction(){const e=<span class="cstat-no" title="statement not covered" >1e-30;</span>function <span class="fstat-no" title="function not covered" >r(</span>h,r,a){let i=<span class="cstat-no" title="statement not covered" >h+r,</span>n=<span class="cstat-no" title="statement not covered" >h+1,</span>p=<span class="cstat-no" title="statement not covered" >h-1,</span>o=<span class="cstat-no" title="statement not covered" >1,</span>u=<span class="cstat-no" title="statement not covered" >1-i*a/n;<span class="cstat-no" title="statement not covered" ></span>Math.abs(u)&lt;e&amp;&amp;(u=e);l</span>et l=<span class="cstat-no" title="statement not covered" >u=1/u;<span class="cstat-no" title="statement not covered" ></span>for(let c=1;c&lt;t;c++){let t=<span class="cstat-no" title="statement not covered" >2*c,</span>m=<span class="cstat-no" title="statement not covered" >c*(r-c)*a/((p+t)*(h+t));<span class="cstat-no" title="statement not covered" ></span>u=1+m*u,Math.abs(u)&lt;e&amp;&amp;(u=e),o=1+m/o,Math.abs(o)&lt;e&amp;&amp;(o=e),l*=(u=1/u)*o,u=1+(m=-(h+c)*(i+c)*a/((h+t)*(n+t)))*u,Math.abs(u)&lt;e&amp;&amp;(u=e),o=1+m/o,Math.abs(o)&lt;e&amp;&amp;(o=e);l</span>et d=<span class="cstat-no" title="statement not covered" >(u=1/u)*o;<span class="cstat-no" title="statement not covered" ></span>if(l*=d,Math.abs(d-1)&lt;s)<span class="cstat-no" title="statement not covered" >break}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn l}<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(t,s,e){let a=<span class="cstat-no" title="statement not covered" >e&lt;=0||e&gt;=1?0:Math.exp(h(t+s)-h(t)-h(s)+t*Math.log(e)+s*Math.log(1-e));<span class="cstat-no" title="statement not covered" ></span>return e&lt;(t+1)/(t+s+2)?a*r(t,s,e)/t:1-a*r(s,t,1-e)/s}</span>}</span>(),erf:<span class="fstat-no" title="function not covered" >fu</span>nction(){const t=<span class="cstat-no" title="statement not covered" >[-1.26551223,1.00002368,.37409196,.09678418,-.18628806,.27886807,-1.13520398,1.48851587,-.82215223,.17087277];<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(s){let e=<span class="cstat-no" title="statement not covered" >1/(1+.5*Math.abs(s)),</span>h=<span class="cstat-no" title="statement not covered" >1,</span>r=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>t.forEach(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >r+=t*h,h*=e}</span>);l</span>et a=<span class="cstat-no" title="statement not covered" >e*Math.exp(r-s*s);<span class="cstat-no" title="statement not covered" ></span>return s&lt;0?a-1:1-a}</span>}</span>(),gamma:e,gammaLn:h,gammaLowerIncomplete:r}}</span>();<span class="cstat-no" title="statement not covered" ></span>e.d(s,"ts",<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return o}</span>),e.d(s,"dist",<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return p}</span>),e.d(s,"mc",<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return u}</span>),e.d(s,"la",<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return i}</span>),e.d(s,"core",<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return a}</span>);l</span>et p=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){const t=<span class="cstat-no" title="statement not covered" >[0,6.635,9.21,11.345,13.277,15.086,16.812,18.475,20.09,21.666,23.209,24.725,26.217,27.688,29.141,30.578,32,33.409,34.805,36.191,37.566,38.932,40.289,41.638,42.98,44.314,45.642,46.963,48.278,49.588,50.892,52.191,53.486,54.776,56.061,57.342,58.619,59.893,61.162,62.428,63.691,64.95,66.206,67.459,68.71,69.957,71.201,72.443,73.683,74.919,76.154,77.386,78.616,79.843,81.069,82.292,83.513,84.733,85.95,87.166,88.379,89.591,90.802,92.01,93.217,94.422,95.626,96.828,98.028,99.228,100.425,101.621,102.816,104.01,105.202,106.393,107.583,108.771,109.958,111.144,112.329,113.512,114.695,115.876,117.057,118.236,119.414,120.591,121.767,122.942,124.116,125.289,126.462,127.633,128.803,129.973,131.141,132.309,133.476,134.642,135.807,136.971,138.134,139.297,140.459,141.62,142.78,143.94,145.099,146.257,147.414,148.571,149.727,150.882,152.037,153.191,154.344,155.496,156.648,157.8,158.95,160.1,161.25,162.398,163.546,164.694,165.841,166.987,168.133,169.278,170.423,171.567,172.711,173.854,174.996,176.138,177.28,178.421,179.561,180.701,181.84,182.979,184.118,185.256,186.393,187.53,188.666,189.802,190.938,192.073,193.208,194.342,195.476,196.609,197.742,198.874,200.006,201.138,202.269,203.4,204.53,205.66,206.79,207.919,209.047,210.176,211.304,212.431,213.558,214.685,215.812,216.938,218.063,219.189,220.314,221.438,222.563,223.687,224.81,225.933,227.056,228.179,229.301,230.423,231.544,232.665,233.786,234.907,236.027,237.147,238.266,239.386,240.505,241.623,242.742,243.86,244.977,246.095,247.212,248.329,249.445,250.561,251.677,252.793,253.908,255.023,256.138,257.253,258.367,259.481,260.595,261.708,262.821,263.934,265.047,266.159,267.271,268.383,269.495,270.606,271.717,272.828,273.939,275.049,276.159,277.269,278.379,279.488,280.597,281.706,282.814,283.923,285.031,286.139,287.247,288.354,289.461,290.568,291.675,292.782,293.888,294.994,296.1,297.206,298.311,299.417,300.522,301.626,302.731,303.835,304.94],</span>s=<span class="cstat-no" title="statement not covered" >[359.906,414.474,468.724,522.717,576.493,630.084,683.516,736.807,789.974,843.029,895.984,948.848,1001.63,1054.334,1106.969];</span>function <span class="fstat-no" title="function not covered" >e(</span>t=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{let e=<span class="cstat-no" title="statement not covered" >Math.random(),</span>h=<span class="cstat-no" title="statement not covered" >Math.random();<span class="cstat-no" title="statement not covered" ></span>return s*Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*h)+t}</span>function <span class="fstat-no" title="function not covered" >h(</span>t,s){<span class="cstat-no" title="statement not covered" >if(!(t&gt;1))<span class="cstat-no" title="statement not covered" >return h(t+1,s)*Math.pow(Math.random(),1/t);{</span></span>let h,r,a,i=<span class="cstat-no" title="statement not covered" >t-1/3,</span>n=<span class="cstat-no" title="statement not covered" >1/Math.sqrt(9*i);<span class="cstat-no" title="statement not covered" ></span>for(;;)<span class="cstat-no" title="statement not covered" >if((h=e(0,1))&gt;-1/n&amp;&amp;(r=Math.pow(1+n*h,3),a=Math.random(),Math.log(a)&lt;.5*h*h+i*(1-r+Math.log(r))))<span class="cstat-no" title="statement not covered" >return i*r/s}</span></span></span>}class a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,s){<span class="cstat-no" title="statement not covered" >this.type=t,this.k=s,this.p=[],this.c=[]}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){<span class="cstat-no" title="statement not covered" >throw Error("Distribution._generator is not implemented")}<span class="fstat-no" title="function not covered" ></span>_p</span>df(t){<span class="cstat-no" title="statement not covered" >throw Error("Distribution._pdf is not implemented")}<span class="fstat-no" title="function not covered" ></span>_c</span>df(t){<span class="cstat-no" title="statement not covered" >throw Error("Distribution._cdf is not implemented")}<span class="fstat-no" title="function not covered" ></span>sa</span>mple(t){<span class="cstat-no" title="statement not covered" >return r(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this._generator(),</span>t)}<span class="fstat-no" title="function not covered" ></span>pd</span>f(t){<span class="cstat-no" title="statement not covered" >return this._pdf(t)}<span class="fstat-no" title="function not covered" ></span>cd</span>f(t){<span class="cstat-no" title="statement not covered" >return this._cdf(t)}<span class="fstat-no" title="function not covered" ></span>su</span>rvival(t){<span class="cstat-no" title="statement not covered" >return 1-this._cdf(t)}<span class="fstat-no" title="function not covered" ></span>ha</span>zard(t){<span class="cstat-no" title="statement not covered" >return this._pdf(t)/this.survival(t)}<span class="fstat-no" title="function not covered" ></span>cH</span>azard(t){<span class="cstat-no" title="statement not covered" >return-Math.log(this.survival(t))}<span class="fstat-no" title="function not covered" ></span>ln</span>Pdf(t){<span class="cstat-no" title="statement not covered" >return Math.log(this._pdf(t))}<span class="fstat-no" title="function not covered" ></span>L(</span>t){<span class="cstat-no" title="statement not covered" >return t.reduce(<span class="fstat-no" title="function not covered" >(t</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >t+this.lnPdf(s),</span>0)}<span class="fstat-no" title="function not covered" ></span>te</span>st(e){<span class="cstat-no" title="statement not covered" >return"discrete"===this.type?<span class="fstat-no" title="function not covered" >fu</span>nction(e,h,r){let a=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>e.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >a[t]=a[t]?a[t]+1:1}</span>);l</span>et i=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >e.length;<span class="cstat-no" title="statement not covered" ></span>for(let t in a)<span class="cstat-no" title="statement not covered" >if(a.hasOwnProperty(t)){let s=<span class="cstat-no" title="statement not covered" >h(parseInt(t))*n;<span class="cstat-no" title="statement not covered" ></span>i+=Math.pow(a[t]-s,2)/s}</span>l</span></span>et p=<span class="cstat-no" title="statement not covered" >Math.max(1,Object.keys(a).length-r-1);<span class="cstat-no" title="statement not covered" ></span>return{statistics:i,passed:i&lt;=(p&lt;=250?t[p]:s[Math.floor(p/50)])}}</span>(e,<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this._pdf(t),</span>this.k):<span class="fstat-no" title="function not covered" >fu</span>nction(t,s){<span class="cstat-no" title="statement not covered" >t.sort(<span class="fstat-no" title="function not covered" >(t</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >t-s)</span>;l</span>et e=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let h=0;h&lt;t.length;h++)<span class="cstat-no" title="statement not covered" >e=Math.max(e,Math.abs((h+1)/t.length-s(t[h])));<span class="cstat-no" title="statement not covered" >r</span></span>eturn{statistics:e,passed:e&lt;=1.628/Math.sqrt(t.length)}}</span>(e,<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this._cdf(t))</span>}</span>}class i extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >super("continuous",arguments.length),this.p={alpha:t,beta:s},this.c=[Math.pow(s,t),n.gamma(t)]}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){<span class="cstat-no" title="statement not covered" >return h(this.p.alpha,this.p.beta)}<span class="fstat-no" title="function not covered" ></span>_p</span>df(t){<span class="cstat-no" title="statement not covered" >return t&gt;0?this.c[0]*Math.exp((this.p.alpha-1)*Math.log(t)-this.p.beta*t)/this.c[1]:0}<span class="fstat-no" title="function not covered" ></span>_c</span>df(t){<span class="cstat-no" title="statement not covered" >return n.gammaLowerIncomplete(this.p.alpha,this.p.beta*t)/this.c[1]}</span>}class p extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >super("continuous",arguments.length),this.p={lambda:t,mu:s},this.c=[.5*this.p.mu/this.p.lambda,Math.exp(2*t/s)]}<span class="fstat-no" title="function not covered" ></span>st</span>atic _phi(t){<span class="cstat-no" title="statement not covered" >return.5*(1+n.erf(t/Math.SQRT2))}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){let t=<span class="cstat-no" title="statement not covered" >e(),</span>s=<span class="cstat-no" title="statement not covered" >t*t,</span>h=<span class="cstat-no" title="statement not covered" >this.p.mu+this.c[0]*this.p.mu*s-this.c[0]*Math.sqrt(this.p.mu*s*(4*this.p.lambda+this.p.mu*s));<span class="cstat-no" title="statement not covered" ></span>return Math.random()&gt;this.p.mu/(this.p.mu+h)?this.p.mu*this.p.mu/h:h}<span class="fstat-no" title="function not covered" ></span>_p</span>df(t){<span class="cstat-no" title="statement not covered" >return t&gt;0?Math.sqrt(this.p.lambda/(2*Math.PI*Math.pow(t,3)))*Math.exp(-this.p.lambda*Math.pow(t-this.p.mu,2)/(2*this.p.mu*this.p.mu*t)):0}<span class="fstat-no" title="function not covered" ></span>_c</span>df(t){let s=<span class="cstat-no" title="statement not covered" >Math.sqrt(this.p.lambda/t),</span>e=<span class="cstat-no" title="statement not covered" >t/this.p.mu;<span class="cstat-no" title="statement not covered" ></span>return t&gt;0?p._phi(s*(e-1))+this.c[1]*p._phi(-s*(e+1)):0}</span>}class o extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >super("continuous",arguments.length),this.p={lambda:t,k:s}}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){<span class="cstat-no" title="statement not covered" >return this.p.lambda*Math.pow(-Math.log(Math.random()),1/this.p.k)}<span class="fstat-no" title="function not covered" ></span>_p</span>df(t){<span class="cstat-no" title="statement not covered" >return t&lt;0?0:this.p.k/this.p.lambda*Math.exp((this.p.k-1)*Math.log(t/this.p.lambda)-Math.pow(t/this.p.lambda,this.p.k))}<span class="fstat-no" title="function not covered" ></span>_c</span>df(t){<span class="cstat-no" title="statement not covered" >return t&lt;0?0:1-Math.exp(-Math.pow(t/this.p.lambda,this.p.k))}</span>}<span class="cstat-no" title="statement not covered" >return{Arcsine:class extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >super("continuous",arguments.length),this.p={a:t,b:s},this.c=[1/Math.PI,s-t]}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){let t=<span class="cstat-no" title="statement not covered" >Math.sin(.5*Math.PI*Math.random());<span class="cstat-no" title="statement not covered" ></span>return t*t*this.c[1]+this.p.a}<span class="fstat-no" title="function not covered" ></span>_p</span>df(t){<span class="cstat-no" title="statement not covered" >return t&gt;=this.p.a&amp;&amp;t&lt;this.p.b?this.c[0]/Math.sqrt((t-this.p.a)*(this.p.b-t)):0}<span class="fstat-no" title="function not covered" ></span>_c</span>df(t){<span class="cstat-no" title="statement not covered" >return t&gt;=this.p.a&amp;&amp;t&lt;this.p.b?2*this.c[0]*Math.asin(Math.sqrt((t-this.p.a)/(this.p.b-this.p.a))):0}</span>},Bernoulli:class extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >.5)</span>{<span class="cstat-no" title="statement not covered" >super("discrete",arguments.length),this.p={p:t}}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){<span class="cstat-no" title="statement not covered" >return Math.random()&lt;this.p.p?1:0}<span class="fstat-no" title="function not covered" ></span>_p</span>df(t){let s=<span class="cstat-no" title="statement not covered" >parseInt(t);<span class="cstat-no" title="statement not covered" ></span>return 1===s?this.p.p:0===s?1-this.p.p:0}<span class="fstat-no" title="function not covered" ></span>_c</span>df(t){<span class="cstat-no" title="statement not covered" >return t&lt;0?0:parseInt(t)&gt;=1?1:1-this.p.p}</span>},Beta:class extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >super("continuous",arguments.length),this.p={alpha:t,beta:s},this.c=[n.beta(t,s)]}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){let t=<span class="cstat-no" title="statement not covered" >h(this.p.alpha,1);<span class="cstat-no" title="statement not covered" ></span>return t/(t+h(this.p.beta,1))}<span class="fstat-no" title="function not covered" ></span>_p</span>df(t){<span class="cstat-no" title="statement not covered" >return t&gt;0&amp;&amp;t&lt;1?Math.pow(t,this.p.alpha-1)*Math.pow(1-t,this.p.beta-1)/this.c[0]:0}<span class="fstat-no" title="function not covered" ></span>_c</span>df(t){<span class="cstat-no" title="statement not covered" >return t&lt;=0?0:t&gt;=1?1:n.betaIncomplete(this.p.alpha,this.p.beta,t)}</span>},BetaPrime:class extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >2,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >2)</span>{<span class="cstat-no" title="statement not covered" >super("continuous",arguments.length),this.p={alpha:t,beta:s}}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){<span class="cstat-no" title="statement not covered" >return h(this.p.alpha,1)/h(this.p.beta,1)}<span class="fstat-no" title="function not covered" ></span>_p</span>df(t){<span class="cstat-no" title="statement not covered" >return t&gt;0?Math.pow(t,this.p.alpha-1)*Math.pow(1+t,-this.p.alpha-this.p.beta)/n.beta(this.p.alpha,this.p.beta):0}<span class="fstat-no" title="function not covered" ></span>_c</span>df(t){<span class="cstat-no" title="statement not covered" >return t&gt;0?n.betaIncomplete(this.p.alpha,this.p.beta,t/(1+t)):0}</span>},Binomial:class extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >100,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >.5)</span>{<span class="cstat-no" title="statement not covered" >super("continuous",arguments.length);l</span>et e=<span class="cstat-no" title="statement not covered" >s&lt;=.5?s:1-s;<span class="cstat-no" title="statement not covered" ></span>this.p={n:t,p:s},this.c=[e,t*e]}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){<span class="cstat-no" title="statement not covered" >if(this.p.n&lt;25){let t=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let s=1;s&lt;=this.p.n;s++)<span class="cstat-no" title="statement not covered" >Math.random()&lt;this.c[0]&amp;&amp;t++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.c[0]===this.p.p?t:this.p.n-t}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.c[1]&lt;1){let t,s=<span class="cstat-no" title="statement not covered" >Math.exp(-this.c[1]),</span>e=<span class="cstat-no" title="statement not covered" >1;<span class="cstat-no" title="statement not covered" ></span>for(t=0;t&lt;=this.p.n&amp;&amp;!((e*=Math.random())&lt;s);t++);l</span>et h=<span class="cstat-no" title="statement not covered" >Math.min(t,this.p.n);<span class="cstat-no" title="statement not covered" ></span>return this.c[0]===this.p.p?h:this.p.n-h}</span>{</span>let t,s,e,h=<span class="cstat-no" title="statement not covered" >this.p.n,</span>r=<span class="cstat-no" title="statement not covered" >n.gammaLn(h+1),</span>a=<span class="cstat-no" title="statement not covered" >1-this.c[0],</span>i=<span class="cstat-no" title="statement not covered" >Math.log(this.c[0]),</span>p=<span class="cstat-no" title="statement not covered" >Math.log(a),</span>o=<span class="cstat-no" title="statement not covered" >Math.sqrt(2*this.c[1]*a);<span class="cstat-no" title="statement not covered" ></span>do{<span class="cstat-no" title="statement not covered" >do{<span class="cstat-no" title="statement not covered" >s=o*(t=Math.tan(Math.PI*Math.random()))+this.c[1]}</span>while(s&lt;0||s&gt;=h+1);<span class="cstat-no" title="statement not covered" >s</span>=Math.floor(s),e=1.2*o*(1+t*t)*Math.exp(r-n.gammaLn(s+1)-n.gammaLn(h-s+1)+s*i+(h-s)*p)}</span>while(Math.random()&gt;e);<span class="cstat-no" title="statement not covered" >r</span>eturn this.c[0]===this.p.p?s:this.p.n-s}</span>}<span class="fstat-no" title="function not covered" >_p</span>df(t){let s=<span class="cstat-no" title="statement not covered" >parseInt(t);<span class="cstat-no" title="statement not covered" ></span>return s&lt;0?0:s&gt;this.p.n?0:Math.exp(n.gammaLn(this.p.n+1)-n.gammaLn(s+1)-n.gammaLn(this.p.n-s+1)+s*Math.log(this.p.p)+(this.p.n-s)*Math.log(1-this.p.p))}<span class="fstat-no" title="function not covered" ></span>_c</span>df(t){let s=<span class="cstat-no" title="statement not covered" >parseInt(t);<span class="cstat-no" title="statement not covered" ></span>return s&lt;0?0:s&gt;=this.p.n?1:n.betaIncomplete(this.p.n-s,1+s,1-this.p.p)}</span>},BoundedPareto:class extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >10,</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >super("continuous",arguments.length),this.p={L:t,H:s,alpha:e},this.c=[Math.pow(t,e),Math.pow(s,e),1-Math.pow(t/s,e)]}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){<span class="cstat-no" title="statement not covered" >return Math.pow((this.c[1]+Math.random()*(this.c[0]-this.c[1]))/(this.c[0]*this.c[1]),-1/this.p.alpha)}<span class="fstat-no" title="function not covered" ></span>_p</span>df(t){<span class="cstat-no" title="statement not covered" >return t&lt;this.p.L||t&gt;this.p.H?0:this.p.alpha*Math.pow(this.p.L/t,this.p.alpha)/(t*this.c[2])}<span class="fstat-no" title="function not covered" ></span>_c</span>df(t){<span class="cstat-no" title="statement not covered" >return t&lt;this.p.L?0:t&gt;this.p.H?1:(1-this.c[0]*Math.pow(t,-this.p.alpha))/(1-this.c[0]/this.c[1])}</span>},Cauchy:class extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >super("continuous",arguments.length),this.p={x0:t,gamma:s},this.c=[Math.PI*this.p.gamma]}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){<span class="cstat-no" title="statement not covered" >return this.p.x0+this.p.gamma*Math.tan(Math.PI*(Math.random()-.5))}<span class="fstat-no" title="function not covered" ></span>_p</span>df(t){let s=<span class="cstat-no" title="statement not covered" >(t-this.p.x0)/this.p.gamma;<span class="cstat-no" title="statement not covered" ></span>return 1/(this.c[0]*(1+s*s))}<span class="fstat-no" title="function not covered" ></span>_c</span>df(t){<span class="cstat-no" title="statement not covered" >return.5+Math.atan2(t-this.p.x0,this.p.gamma)/Math.PI}</span>},Chi2:class extends i{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >2)</span>{<span class="cstat-no" title="statement not covered" >super(Math.round(t)/2,.5)}</span>},Custom:class extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super("discrete",arguments.length),this.p={n:t.length,weights:t};l</span>et s=<span class="cstat-no" title="statement not covered" >t.length,</span>e=<span class="cstat-no" title="statement not covered" >[0],</span>h=<span class="cstat-no" title="statement not covered" >[0],</span>r=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(t.length&gt;1){<span class="cstat-no" title="statement not covered" >for(let e=0;e&lt;s;e++)<span class="cstat-no" title="statement not covered" >r+=t[e];l</span></span>et a=<span class="cstat-no" title="statement not covered" >[],</span>i=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let e=0;e&lt;s;e++)<span class="cstat-no" title="statement not covered" >a.push(s*t[e]/r),a[e]&lt;1?i.push(e):n.push(e);<span class="cstat-no" title="statement not covered" >e</span></span>=[],h=[];<span class="cstat-no" title="statement not covered" >f</span>or(let t=0;t&lt;s;t++)<span class="cstat-no" title="statement not covered" >e.push(1),h.push(t);l</span></span>et p=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;i.length&gt;0&amp;&amp;n.length&gt;0;)<span class="cstat-no" title="statement not covered" >p=i.shift(),o=n.shift(),e[p]=a[p],h[p]=o,a[o]+=a[p]-1,a[o]&lt;1?i.push(o):n.push(o);<span class="cstat-no" title="statement not covered" >f</span></span>or(;n.length&gt;0;)<span class="cstat-no" title="statement not covered" >e[o=n.shift()]=1,h[o]=o;<span class="cstat-no" title="statement not covered" >f</span></span>or(;i.length&gt;0;)<span class="cstat-no" title="statement not covered" >e[p=i.shift()]=1,h[p]=p}</span></span>l</span>et a=<span class="cstat-no" title="statement not covered" >[t[0]/r],</span>i=<span class="cstat-no" title="statement not covered" >[t[0]/r];<span class="cstat-no" title="statement not covered" ></span>for(let s=1;s&lt;t.length;s++)<span class="cstat-no" title="statement not covered" >a.push(t[s]/r),i.push(i[s-1]+t[s]/r);<span class="cstat-no" title="statement not covered" >t</span></span>his.c=[e,h,a,i]}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){<span class="cstat-no" title="statement not covered" >if(this.p.n&lt;=1)<span class="cstat-no" title="statement not covered" >return 0;l</span></span>et t=<span class="cstat-no" title="statement not covered" >Math.floor(Math.random()*this.p.n);<span class="cstat-no" title="statement not covered" ></span>return Math.random()&lt;this.c[0][t]?t:this.c[1][t]}<span class="fstat-no" title="function not covered" ></span>_p</span>df(t){<span class="cstat-no" title="statement not covered" >if(this.p.n&lt;=1)<span class="cstat-no" title="statement not covered" >return 1;{</span></span>let s=<span class="cstat-no" title="statement not covered" >parseInt(t);<span class="cstat-no" title="statement not covered" ></span>return s&lt;0||s&gt;=this.p.weights.length?0:this.c[2][s]}</span>}<span class="fstat-no" title="function not covered" >_c</span>df(t){<span class="cstat-no" title="statement not covered" >if(this.p.n&lt;=1)<span class="cstat-no" title="statement not covered" >return 1;{</span></span>let s=<span class="cstat-no" title="statement not covered" >parseInt(t);<span class="cstat-no" title="statement not covered" ></span>return s&lt;0?0:s&gt;=this.p.weights.length?1:this.c[3][s]}</span>}},Degenerate:class extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >super("continuous",arguments.length),this.p={x0:t}}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){<span class="cstat-no" title="statement not covered" >return this.p.x0}<span class="fstat-no" title="function not covered" ></span>_p</span>df(t){<span class="cstat-no" title="statement not covered" >return t===this.p.x0?1:0}<span class="fstat-no" title="function not covered" ></span>_c</span>df(t){<span class="cstat-no" title="statement not covered" >return t&lt;this.p.x0?0:1}</span>},Erlang:class extends i{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >super(Math.round(t),s)}</span>},Exponential:class extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >super("continuous",arguments.length),this.p={lambda:t}}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){<span class="cstat-no" title="statement not covered" >return-Math.log(Math.random())/this.p.lambda}<span class="fstat-no" title="function not covered" ></span>_p</span>df(t){<span class="cstat-no" title="statement not covered" >return this.p.lambda*Math.exp(-this.p.lambda*t)}<span class="fstat-no" title="function not covered" ></span>_c</span>df(t){<span class="cstat-no" title="statement not covered" >return 1-Math.exp(-this.p.lambda*t)}</span>},F:class extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >2,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >2)</span>{<span class="cstat-no" title="statement not covered" >super("continuous",arguments.length),this.p={d1:t,d2:s},this.c=[n.beta(t/2,s/2),Math.pow(s,s)]}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){<span class="cstat-no" title="statement not covered" >return this.p.d2*h(this.p.d1/2,1)/(this.p.d1*h(this.p.d2/2,1))}<span class="fstat-no" title="function not covered" ></span>_p</span>df(t){<span class="cstat-no" title="statement not covered" >return t&gt;0?Math.sqrt(Math.pow(this.p.d1*t,this.p.d1)*this.c[1]/Math.pow(this.p.d1*t+this.p.d2,this.p.d1+this.p.d2))/(t*this.c[0]):0}<span class="fstat-no" title="function not covered" ></span>_c</span>df(t){<span class="cstat-no" title="statement not covered" >return t&gt;0?n.betaIncomplete(this.p.d1/2,this.p.d2/2,this.p.d1*t/(this.p.d1*t+this.p.d2)):0}</span>},Frechet:class extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >super("continuous",arguments.length),this.p={alpha:t,s:s,m:e}}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){<span class="cstat-no" title="statement not covered" >return this.p.m+this.p.s*Math.pow(-Math.log(Math.random()),-1/this.p.alpha)}<span class="fstat-no" title="function not covered" ></span>_p</span>df(t){<span class="cstat-no" title="statement not covered" >if(t&lt;=this.p.m)<span class="cstat-no" title="statement not covered" >return 0;{</span></span>let s=<span class="cstat-no" title="statement not covered" >(t-this.p.m)/this.p.s;<span class="cstat-no" title="statement not covered" ></span>return this.p.alpha*Math.pow(s,-1-this.p.alpha)*Math.exp(-Math.pow(s,-this.p.alpha))/this.p.s}</span>}<span class="fstat-no" title="function not covered" >_c</span>df(t){<span class="cstat-no" title="statement not covered" >return t&lt;=this.p.m?0:Math.exp(-Math.pow((t-this.p.m)/this.p.s,-this.p.alpha))}</span>},Gamma:i,GeneralizedGamma:class extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >super("continuous",arguments.length),this.p={a:t,d:s,p:e},this.c=[n.gamma(s/e),e/Math.pow(t,s),1/Math.pow(t,e)]}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){<span class="cstat-no" title="statement not covered" >return Math.pow(h(this.p.d/this.p.p,this.c[2]),1/this.p.p)}<span class="fstat-no" title="function not covered" ></span>_p</span>df(t){<span class="cstat-no" title="statement not covered" >return t&gt;0?this.c[1]*Math.exp((this.p.d-1)*Math.log(t)-Math.pow(t/this.p.a,this.p.p))/this.c[0]:0}<span class="fstat-no" title="function not covered" ></span>_c</span>df(t){<span class="cstat-no" title="statement not covered" >return n.gammaLowerIncomplete(this.p.d/this.p.p,Math.pow(t/this.p.a,this.p.p))/this.c[0]}</span>},Gompertz:class extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >super("continuous",arguments.length),this.p={eta:t,b:s}}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){<span class="cstat-no" title="statement not covered" >return Math.log(1-Math.log(Math.random())/this.p.eta)/this.p.b}<span class="fstat-no" title="function not covered" ></span>_p</span>df(t){<span class="cstat-no" title="statement not covered" >return t&lt;0?0:this.p.b*this.p.eta*Math.exp(this.p.eta+this.p.b*t-this.p.eta*Math.exp(this.p.b*t))}<span class="fstat-no" title="function not covered" ></span>_c</span>df(t){<span class="cstat-no" title="statement not covered" >return t&lt;0?0:1-Math.exp(-this.p.eta*(Math.exp(this.p.b*t)-1))}</span>},Gumbel:class extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >super("continuous",arguments.length),this.p={mu:t,beta:s}}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){<span class="cstat-no" title="statement not covered" >return this.p.mu-this.p.beta*Math.log(-Math.log(Math.random()))}<span class="fstat-no" title="function not covered" ></span>_p</span>df(t){let s=<span class="cstat-no" title="statement not covered" >(t-this.p.mu)/this.p.beta;<span class="cstat-no" title="statement not covered" ></span>return Math.exp(-(s+Math.exp(-s)))/this.p.beta}<span class="fstat-no" title="function not covered" ></span>_c</span>df(t){<span class="cstat-no" title="statement not covered" >return Math.exp(-Math.exp(-(t-this.p.mu)/this.p.beta))}</span>},InverseGamma:class extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >super("continuous",arguments.length),this.p={alpha:t,beta:s},this.c=[Math.pow(s,t)/n.gamma(t),n.gamma(t)]}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){<span class="cstat-no" title="statement not covered" >return 1/h(this.p.alpha,this.p.beta)}<span class="fstat-no" title="function not covered" ></span>_p</span>df(t){<span class="cstat-no" title="statement not covered" >return t&gt;0?this.c[0]*Math.pow(t,-1-this.p.alpha)*Math.exp(-this.p.beta/t):0}<span class="fstat-no" title="function not covered" ></span>_c</span>df(t){<span class="cstat-no" title="statement not covered" >return t&gt;0?1-n.gammaLowerIncomplete(this.p.alpha,this.p.beta/t)/this.c[1]:0}</span>},InverseGaussian:p,Laplace:class extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >super("continuous",arguments.length),this.p={mu:t,b:s}}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){<span class="cstat-no" title="statement not covered" >return this.p.b*Math.log(Math.random()/Math.random())+this.p.mu}<span class="fstat-no" title="function not covered" ></span>_p</span>df(t){<span class="cstat-no" title="statement not covered" >return.5*Math.exp(-Math.abs(t-this.p.mu)/this.p.b)/this.p.b}<span class="fstat-no" title="function not covered" ></span>_c</span>df(t){let s=<span class="cstat-no" title="statement not covered" >Math.exp((t-this.p.mu)/this.p.b);<span class="cstat-no" title="statement not covered" ></span>return t&lt;this.p.mu?.5*s:1-.5/s}</span>},LogCauchy:class extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >super("continuous",arguments.length),this.p={mu:t,sigma:s}}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){<span class="cstat-no" title="statement not covered" >return Math.exp(this.p.mu+this.p.sigma*Math.tan(Math.PI*(Math.random()-.5)))}<span class="fstat-no" title="function not covered" ></span>_p</span>df(t){<span class="cstat-no" title="statement not covered" >return t&gt;0?this.p.sigma/(t*Math.PI*(this.p.sigma*this.p.sigma+Math.pow(Math.log(t)-this.p.mu,2))):0}<span class="fstat-no" title="function not covered" ></span>_c</span>df(t){<span class="cstat-no" title="statement not covered" >return t&gt;0?.5+Math.atan2(Math.log(t)-this.p.mu,this.p.sigma)/Math.PI:0}</span>},Logistic:class extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >super("continuous",arguments.length),this.p={mu:t,s:s}}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){<span class="cstat-no" title="statement not covered" >return this.p.mu-this.p.s*Math.log(1/Math.random()-1)}<span class="fstat-no" title="function not covered" ></span>_p</span>df(t){let s=<span class="cstat-no" title="statement not covered" >Math.exp(-(t-this.p.mu)/this.p.s);<span class="cstat-no" title="statement not covered" ></span>return s/(this.p.s*Math.pow(1+s,2))}<span class="fstat-no" title="function not covered" ></span>_c</span>df(t){<span class="cstat-no" title="statement not covered" >return 1/(1+Math.exp(-(t-this.p.mu)/this.p.s))}</span>},LogLogistic:class extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >super("continuous",arguments.length),this.p={mu:t,sigma:s,xi:e}}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){<span class="cstat-no" title="statement not covered" >return this.p.mu+this.p.sigma*(Math.pow(1/Math.random()-1,-this.p.xi)-1)/this.p.xi}<span class="fstat-no" title="function not covered" ></span>_p</span>df(t){let s=<span class="cstat-no" title="statement not covered" >(t-this.p.mu)/this.p.sigma,</span>e=<span class="cstat-no" title="statement not covered" >Math.pow(1+this.p.xi*s,-(1/this.p.xi+1))/(this.p.sigma*Math.pow(1+Math.pow(1+this.p.xi*s,-1/this.p.xi),2));<span class="cstat-no" title="statement not covered" ></span>return 0===this.p.xi?e:this.p.xi&gt;0?t&gt;=this.p.mu-this.p.sigma/this.p.xi?e:0:t&lt;=this.p.mu-this.p.sigma/this.p.xi?e:0}<span class="fstat-no" title="function not covered" ></span>_c</span>df(t){let s=<span class="cstat-no" title="statement not covered" >(t-this.p.mu)/this.p.sigma,</span>e=<span class="cstat-no" title="statement not covered" >1/(1+Math.pow(1+this.p.xi*s,-1/this.p.xi));<span class="cstat-no" title="statement not covered" ></span>return 0===this.p.xi?e:this.p.xi&gt;0?t&gt;=this.p.mu-this.p.sigma/this.p.xi?e:0:t&lt;=this.p.mu-this.p.sigma/this.p.xi?e:0}</span>},Lognormal:class extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >super("continuous",arguments.length),this.p={mu:t,sigma:s},this.c=[s*Math.sqrt(2*Math.PI),s*Math.SQRT2]}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){<span class="cstat-no" title="statement not covered" >return Math.exp(this.p.mu+this.p.sigma*e(0,1))}<span class="fstat-no" title="function not covered" ></span>_p</span>df(t){<span class="cstat-no" title="statement not covered" >return t&gt;0?Math.exp(-.5*Math.pow((Math.log(t)-this.p.mu)/this.p.sigma,2))/(t*this.c[0]):0}<span class="fstat-no" title="function not covered" ></span>_c</span>df(t){<span class="cstat-no" title="statement not covered" >return t&gt;0?.5*(1+n.erf((Math.log(t)-this.p.mu)/this.c[1])):0}</span>},Lomax:class extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >super("continuous",arguments.length),this.p={lambda:t,alpha:s}}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){<span class="cstat-no" title="statement not covered" >return this.p.lambda*(Math.pow(Math.random(),-1/this.p.alpha)-1)}<span class="fstat-no" title="function not covered" ></span>_p</span>df(t){<span class="cstat-no" title="statement not covered" >return t&lt;0?0:this.p.alpha*Math.pow(1+t/this.p.lambda,-1-this.p.alpha)/this.p.lambda}<span class="fstat-no" title="function not covered" ></span>_c</span>df(t){<span class="cstat-no" title="statement not covered" >return t&lt;0?0:1-Math.pow(1+t/this.p.lambda,-this.p.alpha)}</span>},Minimax:class extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >super("continuous",arguments.length),this.p={alpha:t,beta:s}}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){<span class="cstat-no" title="statement not covered" >return Math.pow(1-Math.pow(1-Math.random(),1/this.p.beta),1/this.p.alpha)}<span class="fstat-no" title="function not covered" ></span>_p</span>df(t){<span class="cstat-no" title="statement not covered" >return t&gt;0&amp;&amp;t&lt;1?this.p.alpha*this.p.beta*Math.pow(t,this.p.alpha-1)*Math.pow(1-Math.pow(t,this.p.alpha),this.p.beta-1):0}<span class="fstat-no" title="function not covered" ></span>_c</span>df(t){<span class="cstat-no" title="statement not covered" >return t&gt;0&amp;&amp;t&lt;1?1-Math.pow(1-Math.pow(t,this.p.alpha),this.p.beta):0}</span>},Normal:class extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >super("continuous",arguments.length),this.p={mu:t,sigma:s},this.c=[s*Math.sqrt(2*Math.PI),s*Math.SQRT2]}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){<span class="cstat-no" title="statement not covered" >return e(this.p.mu,this.p.sigma)}<span class="fstat-no" title="function not covered" ></span>_p</span>df(t){<span class="cstat-no" title="statement not covered" >return Math.exp(-.5*Math.pow((t-this.p.mu)/this.p.sigma,2))/this.c[0]}<span class="fstat-no" title="function not covered" ></span>_c</span>df(t){<span class="cstat-no" title="statement not covered" >return.5*(1+n.erf((t-this.p.mu)/this.c[1]))}</span>},Pareto:class extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >super("continuous",arguments.length),this.p={xmin:t,alpha:s}}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){<span class="cstat-no" title="statement not covered" >return this.p.xmin/Math.pow(Math.random(),1/this.p.alpha)}<span class="fstat-no" title="function not covered" ></span>_p</span>df(t){<span class="cstat-no" title="statement not covered" >return t&lt;this.p.xmin?0:this.p.alpha*Math.pow(this.p.xmin/t,this.p.alpha)/t}<span class="fstat-no" title="function not covered" ></span>_c</span>df(t){<span class="cstat-no" title="statement not covered" >return t&lt;this.p.xmin?0:1-Math.pow(this.p.xmin/t,this.p.alpha)}</span>},Poisson:class extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >super("discrete",arguments.length),this.p={lambda:t}}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){<span class="cstat-no" title="statement not covered" >if(this.p.lambda&lt;30){let t=<span class="cstat-no" title="statement not covered" >Math.exp(-this.p.lambda),</span>s=<span class="cstat-no" title="statement not covered" >0,</span>e=<span class="cstat-no" title="statement not covered" >1;<span class="cstat-no" title="statement not covered" ></span>do{<span class="cstat-no" title="statement not covered" >s++,e*=Math.random()}</span>while(e&gt;t);<span class="cstat-no" title="statement not covered" >r</span>eturn s-1}</span>{</span>let t=<span class="cstat-no" title="statement not covered" >.767-3.36/this.p.lambda,</span>s=<span class="cstat-no" title="statement not covered" >Math.PI/Math.sqrt(3*this.p.lambda),</span>e=<span class="cstat-no" title="statement not covered" >s*this.p.lambda,</span>h=<span class="cstat-no" title="statement not covered" >Math.log(t)-this.p.lambda-Math.log(s);<span class="cstat-no" title="statement not covered" ></span>for(;;){let t=<span class="cstat-no" title="statement not covered" >Math.random(),</span>r=<span class="cstat-no" title="statement not covered" >(e-Math.log((1-t)/t))/s,</span>a=<span class="cstat-no" title="statement not covered" >Math.floor(r+.5);<span class="cstat-no" title="statement not covered" ></span>if(a&lt;0)<span class="cstat-no" title="statement not covered" >continue;l</span></span>et i=<span class="cstat-no" title="statement not covered" >Math.random(),</span>p=<span class="cstat-no" title="statement not covered" >e-s*r;<span class="cstat-no" title="statement not covered" ></span>if(p+Math.log(i/Math.pow(1+Math.exp(p),2))&lt;=h+a*Math.log(this.p.lambda)-n.gammaLn(a+1))<span class="cstat-no" title="statement not covered" >return a}</span></span>}</span>}<span class="fstat-no" title="function not covered" >_p</span>df(t){let s=<span class="cstat-no" title="statement not covered" >parseInt(t);<span class="cstat-no" title="statement not covered" ></span>return s&lt;0?0:Math.pow(this.p.lambda,s)*Math.exp(-this.p.lambda)/n.gamma(s+1)}<span class="fstat-no" title="function not covered" ></span>_c</span>df(t){let s=<span class="cstat-no" title="statement not covered" >parseInt(t);<span class="cstat-no" title="statement not covered" ></span>return s&lt;0?0:1-n.gammaLowerIncomplete(s+1,this.p.lambda)/n.gamma(s+1)}</span>},Rayleigh:class extends o{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >super(t*Math.SQRT2,2)}</span>},UniformContinuous:class extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >super("continuous",arguments.length),this.p={xmin:t,xmax:s},this.c=[s-t]}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){<span class="cstat-no" title="statement not covered" >return Math.random()*this.c[0]+this.p.xmin}<span class="fstat-no" title="function not covered" ></span>_p</span>df(t){<span class="cstat-no" title="statement not covered" >return t&lt;this.p.xmin||t&gt;this.p.xmax?0:1/this.c[0]}<span class="fstat-no" title="function not covered" ></span>_c</span>df(t){<span class="cstat-no" title="statement not covered" >return t&lt;this.p.xmin?0:t&gt;this.p.xmax?1:(t-this.p.xmin)/this.c[0]}</span>},UniformDiscrete:class extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >100)</span>{<span class="cstat-no" title="statement not covered" >super("discrete",arguments.length),this.p={xmin:t,xmax:s},this.c=[s-t+1]}<span class="fstat-no" title="function not covered" ></span>_g</span>enerator(){<span class="cstat-no" title="statement not covered" >return parseInt(Math.random()*this.c[0])+this.p.xmin}<span class="fstat-no" title="function not covered" ></span>_p</span>df(t){let s=<span class="cstat-no" title="statement not covered" >parseInt(t);<span class="cstat-no" title="statement not covered" ></span>return s&lt;this.p.xmin||s&gt;this.p.xmax?0:1/this.c[0]}<span class="fstat-no" title="function not covered" ></span>_c</span>df(t){let s=<span class="cstat-no" title="statement not covered" >parseInt(t);<span class="cstat-no" title="statement not covered" ></span>return s&lt;this.p.xmin?0:s&gt;this.p.xmax?1:(1+s-this.p.xmin)/this.c[0]}</span>},Weibull:o,_InvalidDistribution:class extends a{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super("discrete",arguments.length)}</span>}}}</span>(),</span>o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{Cov:class{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >this.dim=t,this.n=0,this.x=new Array(this.dim).fill(0),this.xy=Array.from({length:this.dim},<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >new Array(this.dim).fill(0))</span>}<span class="fstat-no" title="function not covered" ></span>re</span>set(){<span class="cstat-no" title="statement not covered" >this.n=0,this.x=new Array(this.dim).fill(0),this.xy=Array.from({length:this.dim},<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >new Array(this.dim).fill(0))</span>}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){<span class="cstat-no" title="statement not covered" >this.x=this.x.map(<span class="fstat-no" title="function not covered" >(s</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >(this.n*s+t[e])/(this.n+1))</span>,this.xy=this.xy.map(<span class="fstat-no" title="function not covered" >(s</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >s.map(<span class="fstat-no" title="function not covered" >(s</span>,h)=&gt;<span class="cstat-no" title="statement not covered" >(this.n*s+t[e]*t[h])/(this.n+1))</span>)</span>,this.n++}<span class="fstat-no" title="function not covered" ></span>co</span>mpute(){<span class="cstat-no" title="statement not covered" >return new i.Matrix(this.xy.map(<span class="fstat-no" title="function not covered" >(t</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >t.map(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t-this.x[s]*this.x[e])</span>)</span>)}</span>},AC:class{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >100,</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >1e4)</span>{<span class="cstat-no" title="statement not covered" >this.dim=t,this.range=s,this.maxSize=e,this.history=Array.from({length:t},<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >[])</span>}<span class="fstat-no" title="function not covered" ></span>_a</span>ci(t){let s=<span class="cstat-no" title="statement not covered" >t.reduce(<span class="fstat-no" title="function not covered" >(t</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >t+s)</span>/t.length,</span>e=<span class="cstat-no" title="statement not covered" >t.reduce(<span class="fstat-no" title="function not covered" >(t</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >t+s*s)</span>,</span>h=<span class="cstat-no" title="statement not covered" >new Array(this.range).fill(0);<span class="cstat-no" title="statement not covered" ></span>for(let e=0;e&lt;t.length;e++)<span class="cstat-no" title="statement not covered" >for(let r=0;r&lt;h.length;r++)<span class="cstat-no" title="statement not covered" >e-r&gt;0&amp;&amp;(h[r]+=(t[e]-s)*(t[e-r]-s));<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn h.map(<span class="fstat-no" title="function not covered" >fu</span>nction(h){<span class="cstat-no" title="statement not covered" >return h/(e-t.length*s*s)}</span>)}<span class="fstat-no" title="function not covered" ></span>re</span>set(){<span class="cstat-no" title="statement not covered" >this.history=Array.from({length:this.dim},<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >[])</span>}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){<span class="cstat-no" title="statement not covered" >this.history.forEach(<span class="fstat-no" title="function not covered" >(s</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >s.push(t[e]))</span>,this.history[0].length&gt;=this.maxSize&amp;&amp;this.history.forEach(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.shift())</span>}<span class="fstat-no" title="function not covered" ></span>co</span>mpute(){<span class="cstat-no" title="statement not covered" >return this.history.map(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this._aci(t))</span>}</span>}}}</span>(),</span>u=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){const t=<span class="cstat-no" title="statement not covered" >1e4;</span>class s{<span class="fstat-no" title="function not covered" >co</span>nstructor(s,e=<span class="branch-0 cbranch-no" title="branch not covered" >{},</span>h=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >this.dim=e.dim||1,this.maxHistory=e.maxHistory||t,this.lnp=s,this.x=h.x||Array.from({length:self.dim},Math.random),this.samplingRate=h.samplingRate||1,this.internal=h.internal||{},this.history=<span class="fstat-no" title="function not covered" >fu</span>nction(t){let s=<span class="cstat-no" title="statement not covered" >Array.from({length:t.dim},<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >[])</span>;<span class="cstat-no" title="statement not covered" ></span>return{get:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >s,<span class="fstat-no" title="function not covered" ></span>up</span>date(e){<span class="cstat-no" title="statement not covered" >s.forEach(<span class="fstat-no" title="function not covered" >(t</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >t.push(e[s]))</span>,s[0].length&gt;=t.maxHistory&amp;&amp;s.forEach(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.shift())</span>}</span>}}</span>(this),this.acceptance=<span class="fstat-no" title="function not covered" >fu</span>nction(t){let s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return{compute:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >_sum(s)/s.length,<span class="fstat-no" title="function not covered" ></span>up</span>date(e){<span class="cstat-no" title="statement not covered" >s.push(e),s.length&gt;t.maxHistory&amp;&amp;s.shift()}</span>}}</span>(this)}<span class="fstat-no" title="function not covered" ></span>_i</span>nternal(){<span class="cstat-no" title="statement not covered" >throw Error("MCMC._internal() is not implemented")}<span class="fstat-no" title="function not covered" ></span>_i</span>ter(t,s=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >throw Error("MCMC._iter() is not implemented")}<span class="fstat-no" title="function not covered" ></span>_a</span>djust(t){<span class="cstat-no" title="statement not covered" >throw Error("MCMC._adjust() is not implemented")}<span class="fstat-no" title="function not covered" ></span>st</span>ate(){<span class="cstat-no" title="statement not covered" >return{x:this.x,samplingRate:this.samplingRate,internals:this._internal()}}<span class="fstat-no" title="function not covered" ></span>st</span>atistics(){<span class="cstat-no" title="statement not covered" >return this.history.get().map(<span class="fstat-no" title="function not covered" >t=</span>&gt;{let s=<span class="cstat-no" title="statement not covered" >t.reduce(<span class="fstat-no" title="function not covered" >(t</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >t+s,</span>0)/t.length,</span>e=<span class="cstat-no" title="statement not covered" >t.reduce(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t+(e-s)*(e-s),</span>0)/t.length;<span class="cstat-no" title="statement not covered" ></span>return{mean:s,std:e,cv:e/s}}</span>)}<span class="fstat-no" title="function not covered" ></span>ar</span>(){<span class="cstat-no" title="statement not covered" >return this.acceptance.compute()}<span class="fstat-no" title="function not covered" ></span>ac</span>(){<span class="cstat-no" title="statement not covered" >return this.history.get().map(<span class="fstat-no" title="function not covered" >t=</span>&gt;{let s=<span class="cstat-no" title="statement not covered" >t.reduce(<span class="fstat-no" title="function not covered" >(t</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >t+s)</span>/t.length,</span>e=<span class="cstat-no" title="statement not covered" >t.reduce(<span class="fstat-no" title="function not covered" >(t</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >t+s*s)</span>,</span>h=<span class="cstat-no" title="statement not covered" >new Array(100).fill(0);<span class="cstat-no" title="statement not covered" ></span>for(let e=0;e&lt;t.length;e++)<span class="cstat-no" title="statement not covered" >for(let r=0;r&lt;h.length;r++)<span class="cstat-no" title="statement not covered" >e-r&gt;0&amp;&amp;(h[r]+=(t[e]-s)*(t[e-r]-s));<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn h.map(<span class="fstat-no" title="function not covered" >fu</span>nction(h){<span class="cstat-no" title="statement not covered" >return h/(e-t.length*s*s)}</span>)}</span>)}<span class="fstat-no" title="function not covered" ></span>it</span>erate(t=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{let e=<span class="cstat-no" title="statement not covered" >this._iter(this.state.x,s);<span class="cstat-no" title="statement not covered" ></span>return this.history.update(e.x),this.acceptance.update(e.accepted),this.x=e.x,t&amp;&amp;t(e.x,e.accepted),e}<span class="fstat-no" title="function not covered" ></span>wa</span>rmUp(t,s=<span class="branch-0 cbranch-no" title="branch not covered" >100)</span>{<span class="cstat-no" title="statement not covered" >for(let e=0;e&lt;=s;e++){<span class="cstat-no" title="statement not covered" >for(let t=0;t&lt;1e4;t++)<span class="cstat-no" title="statement not covered" >this._adjust(this.iterate(null,!0));l</span></span>et h=<span class="cstat-no" title="statement not covered" >this.ac().reduce(<span class="fstat-no" title="function not covered" >(t</span>,s)=&gt;{<span class="cstat-no" title="statement not covered" >for(let e=0;e&lt;s.length-1;e++)<span class="cstat-no" title="statement not covered" >if(Math.abs(s[e])&lt;=.05)<span class="cstat-no" title="statement not covered" >return Math.max(t,e)}</span></span></span>,0);<span class="cstat-no" title="statement not covered" ></span>h&gt;this.samplingRate?this.samplingRate++:h&lt;this.samplingRate&amp;&amp;this.samplingRate&gt;1&amp;&amp;this.samplingRate--,t&amp;&amp;t(100*e/s)}</span>}<span class="fstat-no" title="function not covered" ></span>sa</span>mple(t,s=<span class="branch-0 cbranch-no" title="branch not covered" >1e3)</span>{let e=<span class="cstat-no" title="statement not covered" >this.samplingRate*s,</span>h=<span class="cstat-no" title="statement not covered" >e/100,</span>r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let s=0;s&lt;e;s++)<span class="cstat-no" title="statement not covered" >this.iterate(),s%h==0&amp;&amp;t&amp;&amp;t(s/h),s%this.samplingRate==0&amp;&amp;r.push(this.x);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>}<span class="cstat-no" title="statement not covered" >return{gr:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t,s){<span class="cstat-no" title="statement not covered" >return t[0][0].map(<span class="fstat-no" title="function not covered" >fu</span>nction(e,h){<span class="cstat-no" title="statement not covered" >return new Array(s||1e3).fill(0).map(<span class="fstat-no" title="function not covered" >fu</span>nction(s,e){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t,s){let e=<span class="cstat-no" title="statement not covered" >[],</span>h=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>t.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(t){let r=<span class="cstat-no" title="statement not covered" >t.map(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t[s]}</span>),</span>a=<span class="cstat-no" title="statement not covered" >_sum(r)/r.length,</span>i=<span class="cstat-no" title="statement not covered" >(_sum(r,2)-r.length*a*a)/(r.length-1);<span class="cstat-no" title="statement not covered" ></span>e.push(a),h.push(i)}</span>);l</span>et r=<span class="cstat-no" title="statement not covered" >_sum(h)/t.length,</span>a=<span class="cstat-no" title="statement not covered" >_sum(e)/t.length,</span>i=<span class="cstat-no" title="statement not covered" >(_sum(e,2)-t.length*a*a)*t[0].length/(t.length-1),</span>n=<span class="cstat-no" title="statement not covered" >((t[0].length-1)*r+i)/t[0].length;<span class="cstat-no" title="statement not covered" ></span>return Math.sqrt(n/r)}</span>(t.map(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.slice(0,e+2)}</span>),h)}</span>)}</span>)}</span>}</span>(),RWM:class extends s{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,s,e){<span class="cstat-no" title="statement not covered" >super(t,s,e),this.lastLnp=this.lnp(this.x),this.proposal=<span class="fstat-no" title="function not covered" >fu</span>nction(t){let s=<span class="cstat-no" title="statement not covered" >new p.Normal(0,1),</span>e=<span class="cstat-no" title="statement not covered" >new Array(t.dim).fill(0),</span>h=<span class="cstat-no" title="statement not covered" >t.internal.proposal||new Array(t.dim).fill(1),</span>r=<span class="cstat-no" title="statement not covered" >h.map(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Math.log(t))</span>,</span>a=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return{jump:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e?t.map(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t+(e===n?s.sample()*h[n]:0))</span>:t.map(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t+s.sample()*h[e])</span>,<span class="fstat-no" title="function not covered" ></span>up</span>date(s){<span class="cstat-no" title="statement not covered" >s&amp;&amp;e[n]++,100==++a&amp;&amp;(e[n]/100&gt;.44?r[n]+=Math.min(.01,Math.pow(i,-.5)):r[n]-=Math.min(.01,Math.pow(i,-.5)),h[n]=Math.exp(r[n]),a=0,e[n]=0,0==(n=(n+1)%t.dim)&amp;&amp;i++)}</span>,scales:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >h.slice()}</span>}</span>(this)}<span class="fstat-no" title="function not covered" ></span>_i</span>nternal(){<span class="cstat-no" title="statement not covered" >return{proposal:this.proposal.scales()}}<span class="fstat-no" title="function not covered" ></span>_i</span>ter(t,s){let e=<span class="cstat-no" title="statement not covered" >this.proposal.jump(this.x,s),</span>h=<span class="cstat-no" title="statement not covered" >this.lnp(e),</span>r=<span class="cstat-no" title="statement not covered" >Math.random()&lt;Math.exp(h-this.lastLnp);<span class="cstat-no" title="statement not covered" ></span>return r?this.lastLnp=h:e=this.x,{x:e,accepted:r}}<span class="fstat-no" title="function not covered" ></span>_a</span>djust(t){<span class="cstat-no" title="statement not covered" >this.proposal.update(t.accepted)}</span>}}}</span>()}</span>]);</span></pre></td></tr>
</table></pre>
<div class='push'></div><!-- for sticky footer -->
</div><!-- /wrapper -->
<div class='footer quiet pad2 space-top1 center small'>
  Code coverage
  generated by <a href="https://istanbul.js.org/" target="_blank">istanbul</a> at Tue Jan 22 2019 18:58:05 GMT+0100 (Central European Standard Time)
</div>
</div>
<script src="../../prettify.js"></script>
<script>
window.onload = function () {
        if (typeof prettyPrint === 'function') {
            prettyPrint();
        }
};
</script>
<script src="../../sorter.js"></script>
<script src="../../block-navigation.js"></script>
</body>
</html>
